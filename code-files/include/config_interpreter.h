#ifndef CONFIG_INTERPRETER_H
#define CONFIG_INTERPRETER_H

#include <fstream>
#include <map>
#include <string>
#include <vector>
#include <unordered_map>
#include "nginx_config.h"

// Config struct to hold URI, handler, and arguments for each location block
struct ConfigStruct{
  std::string uri;
  std::string handler;
  std::unordered_map<std::string, std::string> args;
};

// Parses and validates a config file from an input stream. Returns none.
// @param config_file: input stream of the config file.
// @param config: NginxConfig object to populate with parsed data..
void process_config_file(std::ifstream& config_file, NginxConfig& config);

// Recursively searches for the value of a given key in a config block.
// @param config_block: pointer to the config block to search.
// @param key: the directive name to look up.
// @return: value string if found, else empty string.
std::string find_value_for_key(const NginxConfig* config_block, const std::string& key);

// Extracts the port number from the "listen" directive.
// @param config_block: pointer to the config block to search.
// @return: port number as a short; returns -1 if not found or invalid.
short find_listen_port(const NginxConfig* config_block);

// Extracts handler configurations as a list of ConfigStruct objects.
// @param config_block: pointer to the config block to search.
// @return: vector of ConfigStruct objects containing uri, handler, and args.
std::vector<ConfigStruct> extract_handler_configs(const NginxConfig* config_block);

// Creates a map of URIs to ConfigStucts and fails if duplicates exist
// @param handler_configs: vector of handler condigs generated by extract_handler_condfigs
// @return: map of URIs to ConfigStructs 
std::map<std::string, ConfigStruct> create_uri_to_config_map(const std::vector<ConfigStruct>& handler_configs);

#endif // CONFIG_INTERPRETER_H